# DDQ

调度器


## 编译

```
make target=cpu
```
或
```
make target=tianhe3_dsp
```
等

MacOs下可能会遇到
```
 xcode-select: Failed to locate 'm4'
```
 的问题，是xcode15.3自身的问题，需要执行以下命令修复
```
sudo ln -s /Library/Developer/CommandLineTools/usr/bin/gm4 /Library/Developer/CommandLineTools/usr/bin/m4
```

目前的安装文件夹在compiled\_cpu，其他target的名字类推。

可执行文件安装在compiled\_cpu/bin下，目前只有ddqrun，这个程序接受一个ddq脚本文件作为输入。
oplib的所有.so和.ddq文件都安装在compiled\_cpu/usr/oplib下，ddqrun可以自动找到它们。


## 运行


运行
```
make
./compiled_cpu/bin/ddqrun tests/test_int.ddq
```



## DDQ的运行规则

- DDQ只认识两种东西：对象和算子
- 每个对象对于DDQ而言只是一个void*指针，以及(可选的)建构和析构函数。用obj_dup可以实现不同对象共享这些东西
- 对象有(互斥的)状态，包括：可读、可写、正被写、未创建
- 算子是一些对象的关系，包括一个函数对象(对，我们一般说的task_f类型的算子其实是对象)、若干输入对象、若干输出对象
- 算子被运行的条件是：函数对象和所有输入对象都可读、所有输出对象都可写或未创建(此时会被创建)
- 未创建的对象被建构函数创建后，处于可写状态
- 算子运行时，它的所有输出对象转变为正被写状态；算子执行完毕之后，它的所有输出对象转变为可读状态
- 用obj_import引入的对象，可以添加ready标记使其直接可读
- 对象可以有消耗品标记，带有这个标记的对象，在所有把它作为输入对象的算子各运行完毕一次之后，转为可写状态
- 当算子的函数对象返回done后，析构算子
- 当算子的任意非消耗品输出对象可读时，析构算子
- 当算子的任意消耗品输入对象可写、却不是任何算子的输出对象，析构算子
- (是否加入此条？) 当算子的任意消耗品输出对象可读、却不是任何算子的输入对象，析构算子???
- 当对象不被任何算子引用时，析构对象
- 当所有算子都被析构之后，退出ddq_loop


## DDQ脚本示例

### 声明一个类型

```
newtype.new = load_so(lqcd/types/LatticePropagator/fnew)
newtype.del = load_so(lqcd/types/LatticePropagator/fdel)
```

这里用newtype关键字声明了一个类型。

ddq脚本里的对象类型，本质上就是一对建构/析构函数。具有相同建构/析构函数的对象，判断为类型相同。

在这个例子里，这两个函数是从"lqcd/types/LatticePropagator.so"文件里读取的。

相关语法规则：
- 等号"="表示等价关系，左右是对称的。因为不存在变量，所以大多数情况下也可以理解为赋值，就像其他语言那样。
- 用二元运算符小数点"."表示取属性，其左边是表示类型、对象或算子的名字或关键字（类似其他语言的左值概念），其右边是表示属性域的名字或整数。
- 对类型有效的属性包括new和del，另外以后可能会有关于序列化的属性
- load\_so(path/to/file/function)是从"path/to/file.so"文件中读取出function函数指针。这个路径起点为安装所有算子的根位置，路径不可包含".."等有越狱嫌疑的东西，但支持软/硬链接。
- 与load\_so类似的，还有load\_builtin、load\_tianhe(待实现)等。
- 一个.ddq脚本文件里，只能包含newtype/newop中的一个，或两者皆无。包含这样的关键字的脚本文件，可以在其他脚本中用load\_type/load\_op调入；不包含这样的关键字的脚本文件，可以作为主数据流图直接调入运行。


### 声明一个基本算子

```
newop.f = load_so(lqcd/inverter/wilson/eo_prec)
newop.processor = "pthread"
[load_type(lqcd/types/LatticePropagator)] < newop < [load_type(lqcd/types/LatticePropagator) load_type(lqcd/types/LatticeGauge)]
newop<2 = newop.conf
```

这里用newop关键字声明了一个算子，把它的实际运行的算子函数指定为从"lqcd/inverter/wilson.so"文件中读入的"eo\_prec"函数，这个函数应为C语言的task\_f类型。

这里为这个算子的输入输出指定了参数个数、参数别名、以及参数类型等。
这个例子里，这个算子有两个输入和一个输出，其中第二个输入被改为用名字指定，其他用顺序指定。
它们的类型用load\_type指定，在诸如"lqcd/types/LatticePropagator.ddq"这样的文件里声明。

相关语法规则：
- 算子的属性f表示算子的函数指针。
- 算子的负整数属性对应其输入对象，正整数属性对应其输出对象，从-1或1开始，按绝对值增加顺序排列。
- 算子的输入输出的参数名自动成为算子的属性，输入和输出的参数名不可重名，也不可以为processor或整数。可以把这些参数与整数属性用=关联起来。
- “<”和"[]"等都是语法糖，本质是设置一系列属性。
- 把算子的输入输出设置为类型，语义是把对应的输入输出对象的type属性设置为类型，其实质是设置这些对象的new/del属性。因为脚本中无变量，冲突的设置会导致错误，这是类型推导的实现方式。
- 基本算子有processor属性，用于指定运行的驱动。


### 实现一个复合算子

```
[p] < newop < [fn]
b = load_op(lqcd/guage/load)
c = load_op(lqcd/fermion/makesource/point)
d = load_op(lqcd/inverter/wilson/eo_prec)
[g] < b < [fn]
[s] < c
[p] < d < [s conf:g]
```

这里用newop关键字声明了一个算子。
这个算子是复合算子，与基本算子不同，脚本不指定它的C算子函数，而是用其他已有的算子把它组合出来。

在这个例子里，使用load\_op从"lqcd/inverter/wilson/eo\_prec.ddq"等文件中调入了若干算子，并为它们建立了数据流图。
同时，也为newop指定了输入和输出的对象列表，并以这些对象为桥梁，建立了新算子与已有算子的组合之间的等价关系。

相关语法规则：
- 名字可以指代对象、算子或类型，无需事先声明。
- 脚本中的所有行的顺序是没有意义的，可任意排列。
- 为算子指定参数时，需要略注意参数的顺序。为了不发生顺序冲突，我们建议有名字的参数放在后面，作为风格上的约定。
- 这种定义复合算子的语法的底层逻辑是：所谓“定义”，无非就是个等价关系而已。


### 使用算子的几种方法

1、直接拿来用：
```
f = load_op(path/to/fun)

[...] < f < [...]
f.someparam = blah

[...] < load_op(path/to/fun) < [...]
```

如上的写法，可以把算子在脚本中直接展开，做成完整的运行图后交给ddq去运行。换句话说，程序是在编译期确定的。

脚本中的每个load\_op会各自展开为相应的子图，其中一些可以用=与某些名字建立等价关系，另一些可以选择直接拿来用而不分配名字。
有名字的好处是，可以用多个语句对其指定额外的参数等。

2、在运行时调用：
```
f := load_op(path/to/fun)

[...] < f < [...]

[...] < f < [...]
```

如上的写法，用:=声明了算子，此时f并不直接对应于某个子图，代码中每次出现的f都会被替换为各自独立的子图。

从实现技术上看，这些子图并非简单地复制指定的算子，而是用“运行时编译”和“桥接子图”两个内置算子，在运行时把f的内容转译为图，然后运行它。

这样的做法，从大的意义上看，可以为传统的有向图描述的工作流提供近乎图灵完全的语法能力，实现复杂的程序结构——比如递归、远程分派等；而从小的意义上看，这个写法似乎更符合其他编程语言的习惯，用户可能更容易理解。

当然灵活性和易用性是有代价的，相比编译期处理的方法，运行时做转译会有一定开销——具体情况需要实测。

其他语法规则：
- 声明算子的":="符号，与声明相等关系的"="符号，完全不同。后者是左右对称的且取值类型宽泛，前者的左边只能名字、右边只能是load\_op


### 其他语法细节

脚本中可以有整数、实数和字符串常数，只能做右值，是用obj\_import函数引入的对象：
```
a = 3
b = 3.14
b.consumable = TRUE
c = "a string"
```
这几个对象的属性可以被自动设置为可读的非消耗品，但可以通过设置其consumable属性来覆盖默认值。

其他语法规则：
- 类似地，没有被指定为常数的名字，如果是用来表示对象的，那么这个对象的属性是待建立的消耗品。可以在脚本里类似的设置以覆盖默认值。


我们可以用符号"~"表示复制对象：
```
p = load_op(lqcd/inverter/wilson/eo_prec)
b ~ a
[b] < p < [a]
```
此时，对象a和b共用一个内存实例，但在数据流图里是两个不同的对象。
这个特殊规定一般适用于需要复用内存的情况。

这个复制语法的可能用途：
- 类似chroma中的情况，算子的输入输出需要是同一个内存指针
- 如果有一个对象是用collect的逻辑生成的，也就是说，有若干个算子可以输出这个对象的不同部分的数据，这些算子都完成后，这个对象才生成完毕。那么就需要dup关系的对象承载多个算子的输出，并再通过一个什么都不干的算子把“它们”整合为一个同样位置的对象。
- 类似socket等双向通讯的对象，带有自己的缓冲区，随时可以接受输入输出，因此它的状态无法用ddq对象的状态直接描述，更适合描述为两个对象，分别负责输入和输出。因此可以使用dup对象——当然也未必一定需要dup，这取决于具体的需求模型。
- 类似对象池子的东西，需要维护一些资源，通过输出对象提供资源、通过输入对象返还资源。这个我还没有想清楚具体实现方法，但有可能需要若干算子和若干dup对象来实现一个通用的方案。这个后续会是一个基本的通用工具。
- 动态准备ring并当场运行时，需要把新的ring里放入原有的obj以实现输入输出，此时应当放入dup的obj。


### 目前未解决的问题

- 对于iterator的支持可能是间接的，需要确认一下实现的方式是否直观。




### 脚本语法的BNF描述

(已过时，需要更新)

- 代码 := 空 | 赋值 代码 | 连接 代码
- 赋值 := 名字 = 对象 | 属性 = 对象 | 名字 = 赋值
- 名字 := 字符串
- 属性 := 名字 . 名字 | 名字 < 整数 | 整数 < 名字
- 对象 := 名字 | 属性 | 整数 | "字符串" | True | False | 装载
- 装载 := 装载命令 ( 装载项 )
- 装载命令 := load\_op | load\_type | load\_data | load\_so
- 装载项 := 字符串 | 字符串 / 装载项
- 连接 := 连接1 | 连接2
- 连接1 := 对象 < [ 列表 ] | 连接2 < [ 列表 ]
- 连接2 := [ 列表 ] < 对象 | 连接1 < 对象
- 列表 := 空 | 对象 列表 | 名字 : 对象 列表



