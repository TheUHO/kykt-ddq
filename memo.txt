

关于算子的析构：
	析构发生在运行完毕之后，内存释放发生在下一轮循环时：
		当处理器模块为ddq_while(condition)输入的条件为0时，则析构算子
			这是逻辑要求
		当返回值不是partial_write时，当有任意有效输出对象不是消耗品，则析构算子
			这是因为非消耗品不可以被多次写入
		当返回值不是partial_read时：当有任意输入对象是消耗品，且它的输入算子个数为0（如果支持竞争则还要要求对象不可竞争）
	析构也可以发生在运行之前：
		当有任意输入对象是消耗品，且它的输入算子个数为0，且它的状态是towrite。FIXME: 其他状态呢？
		当有任意输出对象是消耗品，且它的输出算子个数为0？？
	所有算子都被析构之后，退出ddq_loop()


关于对象的析构：
	所有算子所引用到的对象，会被交接所有权并纳入ddq管理。使用者不应当再使用它们。
	当一个对象不再被任何算子引用时，它的obj_t内存会被释放。在此之前，如果这个对象是用obj_new()函数建立的，且指定了析构函数指针，则会被析构。


关于相等和属性的概念：
	相等关系是对称的：
		a = b 可推出 b = a
	相等的属性可以互相替换：
		x = y 可推出 a.x = a.y
	相等关系可以通过lvalue传递：
		当b是lvalue时：
			a = b 且 b = c 可推出 a = c
	属性可以通过lvalue传递：
		当b是lvalue时：
			a = b 且 a.x = c 可推出 b.x = c



